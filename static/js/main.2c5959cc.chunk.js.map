{"version":3,"sources":["SnoowrapCache.ts","Playlist.tsx","Player.tsx","constants.ts","PlaylistLoader.tsx","types.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["token","snoowrap","error","Playlist","songs","currentSong","setCurrentSong","setPlaying","playlist","index","song","playlistClasses","push","className","key","onClick","title","platform","entries","Player","playing","setPlaylistEvent","useState","volume","setVolume","muted","setMuted","currentPlatform","undefined","onEnded","type","ref","React","createRef","playerProps","targetPlatform","url","onPlay","onPause","onReady","setTimeout","onError","controls","platformDefaultUrls","loop","current","seekTo","getDuration","min","max","step","defaultValue","onChange","e","parseFloat","currentTarget","value","USER_AGENT","version","ongoingPromise","isValid","expiresOn","getTime","Date","now","refresh","a","form","FormData","set","fetch","method","headers","authorization","btoa","CLIENT_ID","body","response","ok","Error","json","tokenInfo","object","access_token","expires_in","accessToken","Snoowrap","userAgent","convertToSongs","submissions","reduce","acc","submission","convertToSong","concat","secure_media","commentsUrl","permalink","votes","score","PlaylistLoader","playlistEvent","subreddit","listing","setListing","setSongs","fetchMoreOptions","cancel","catch","refreshSnoowrap","getSubreddit","getHot","finally","tempListing","tempSongs","length","fetchMore","App","setSubreddit","lockCount","setLockCount","lock","onKeyPress","fallback","amount","append","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"6JAgBIA,EACAC,EACAC,E,kFCPSC,G,YAAoC,SAAC,GAK3C,IAJLC,EAII,EAJJA,MACAC,EAGI,EAHJA,YACAC,EAEI,EAFJA,eACAC,EACI,EADJA,WAEMC,EAAW,GADb,uBAEJ,IAFI,IAEJ,EAFI,2BAEQC,GAFR,uBAEeC,EAFf,KAGEC,EAAkB,iBAClBF,IAAUJ,IACZM,GAAmB,4BAErBH,EAASI,KACP,wBAAIC,UAAWF,EAAiBG,IAAKL,GACnC,4BACEI,UAAU,yBACVE,QAAS,WACPT,EAAeG,GACfF,GAAW,KAGZG,EAAKM,OAEPN,EAAKO,YAhBZ,EAA4Bb,EAAMc,UAAlC,+CAA6C,CAAC,IAAD,OAFzC,kFAsBJ,OAAO,yBAAKL,UAAU,YAAYL,KCrBvBW,EAAgC,SAAC,GAOvC,IANLC,EAMI,EANJA,QACAb,EAKI,EALJA,WACAF,EAII,EAJJA,YACAC,EAGI,EAHJA,eACAF,EAEI,EAFJA,MACAiB,EACI,EADJA,iBACI,EACwBC,mBAAiB,GADzC,mBACGC,EADH,KACWC,EADX,OAEsBF,oBAAkB,GAFxC,mBAEGG,EAFH,KAEUC,EAFV,KAGEC,OACmBC,IAAvBxB,EAAMC,QAA6BuB,EAAYxB,EAAMC,GAAaY,SAE9DY,EAAU,gBACiBD,IAA3BxB,EAAMC,EAAc,IACtBgB,EAAiB,CAAES,KAAM,cAE3BxB,EAAeD,EAAc,IAG3B0B,EAAMC,IAAMC,YAEVC,EAAc,SAACC,GAAD,OAClBR,IAAoBQ,EAChB,CACEJ,IAAKA,EACLK,IAAKhC,EAAMC,GAAa+B,IACxBb,OAAQA,EACRE,MAAOA,EACPL,QAASA,EACTiB,OAAQ,kBAAM9B,GAAW,IACzB+B,QAAS,kBAAM/B,GAAW,IAC1BgC,QAAS,kBAAMC,YAAW,kBAAMjC,GAAW,KAAO,MAClDsB,QAASA,EACTY,QAASZ,EACTa,UAAU,GAEZ,CACEN,IAAKO,EAAoBR,GACzBZ,OAAQA,EACRE,OAAO,EACPL,QAASA,EACTwB,MAAM,EACNF,UAAU,IAGlB,OACE,kBAAC,WAAD,KACE,kBAAC,IAAkBR,EAAY,gBAC/B,kBAAC,IAAqBA,EAAY,mBAClC,4BACEnB,QAAS,kBACPT,EAAeD,EAAc,EAAIA,EAAc,EAAIA,KAFvD,YAOA,4BAAQU,QAAS,kBAAMR,GAAYa,KAChCA,EAAU,QAAU,QAEvB,4BAAQL,QAASc,GAAjB,QACA,4BACEd,QAAS,WACHgB,EAAIc,SACNd,EAAIc,QAAQC,OAAOf,EAAIc,QAAQE,cAAgB,KAHrD,eASA,4BAAQhC,QAAS,kBAAMW,GAAUD,KAC9BA,EAAQ,SAAW,QAEtB,2BACEK,KAAK,QACLkB,IAAI,IACJC,IAAI,IACJC,KAAK,OACLC,aAAc5B,EACd6B,SAAU,SAAAC,GAAC,OAAI7B,EAAU8B,WAAWD,EAAEE,cAAcC,WAEtD,kBAAC,EAAD,CACEpD,MAAOA,EACPC,YAAaA,EACbC,eAAgBA,EAChBC,WAAYA,MAMdoC,EAAqD,CACzD,cAAe,8CACf,iBAAkB,8D,kDC5GPc,EAAU,4BAAwBC,IAAxB,sBHkBhB,IIFHC,EJcEC,EAAU,uBACDhC,IAAb3B,QACU2B,IAAV5B,GACAA,EAAM6D,UAAUC,UG/BW,IH+BiBC,KAAKC,OAE7CC,EAAO,uCAAG,gCAAAC,EAAA,6DACRC,EAAO,IAAIC,UACZC,IAAI,aAAc,oDACvBF,EAAKE,IAAI,YAAa,4BAHR,SAISC,MAAM,6CAA8C,CACzEC,OAAQ,OACRC,QAAS,CAAEC,cAAc,SAAD,OAAWC,KAAKC,qBACxCC,KAAMT,IAPM,WAIRU,EAJQ,QASAC,GATA,sBAUN,IAAIC,MAAM,mCAVJ,wBAYUF,EAASG,OAZnB,WAYRC,EAZQ,OA1BmB,kBAFNC,EAyCFD,GAvCTE,cACe,kBAAtBD,EAAOE,WAyBF,uBAcN,IAAIL,MAAM,2CAdJ,SAgBd/E,EAAQiF,GACFpB,UAAY,IAAIE,KAAKA,KAAKC,MAA+B,IAAvBiB,EAAUG,iBACjCxD,IAAb3B,EACFA,EAASoF,YAAcrF,EAAMmF,aAE7BlF,EAAW,IAAIqF,IAAS,CACtBC,UAAW9B,EACX4B,YAAarF,EAAMmF,eAvBT,kCA5BhB,IAA6BD,IA4Bb,OAAH,qDKjBAM,EAAiB,SAC5BC,GAEA,YAAoB7D,IAAhB6D,EACK,GAGFA,EAAYC,QAAe,SAACC,EAAaC,GAC9C,IAAMlF,EAAOmF,EAAcD,GAC3B,YAAgBhE,IAATlB,EAAqBiF,EAAMA,EAAIG,OAAOpF,KAC5C,KAGQmF,EAAgB,SAACD,GAjBJ,IAACV,EAkBzB,GAC8B,OAA5BU,EAAWG,eAlBK,iBADOb,EAoBXU,EAAWG,aAAajE,OAnBQ,mBAAXoD,GAwBnC,MAAO,CACLlE,MAAO4E,EAAW5E,MAClBgF,YAAaJ,EAAWK,UACxB7D,IAAKwD,EAAWxD,IAChBnB,SAAU2E,EAAWG,aAAajE,KAClCoE,MAAON,EAAWO,QD1BTC,EAAgD,SAAC,GASvD,IARLC,EAQI,EARJA,cACAhF,EAOI,EAPJA,iBACAiF,EAMI,EANJA,UACAC,EAKI,EALJA,QACAC,EAII,EAJJA,WACApG,EAGI,EAHJA,MACAqG,EAEI,EAFJA,SACAC,EACI,EADJA,iBAEA,GAA2B,UAAvBL,EAAcvE,KAChB,OAAO,KAGL6B,GACFA,EAAegD,SAGjB,IAAM1G,EJlBuB,WAC7B,GAAIC,EACF,MAAMA,EAER,GAAI0D,IACF,OAAO3D,EAET,MAAMgE,IAAU2C,OAAM,SAAAvD,GACpBnD,EAAQmD,KIUOwD,GAEjB,GACyB,YAAvBR,EAAcvE,WACDF,IAAZ2E,GAAgD,cAAvBF,EAAcvE,KAWxC,MATW,uCAAG,4BAAAoC,EAAA,6DACZP,EAAiB1D,EACd6G,aAAaR,GACbS,SACAC,SAAQ,kBAAM3F,EAAiB,CAAES,KAAM,aAJ9B,SAKc6B,EALd,OAKNsD,EALM,OAMZT,EAAWS,GACXR,EAASjB,EAAeyB,IAPZ,2CAAH,oDASL3C,GACD,GAA2B,cAAvB+B,EAAcvE,WAAoCF,IAAZ2E,EAgB/C,MAfe,uCAAG,8BAAArC,EAAA,sDACZ+C,EAAcV,EACdW,EAAoB,GAFR,YAGTA,EAAUC,QAAU/G,EAAM+G,QAHjB,wBAIdxD,EAAmBsD,EAEhBG,UAAUV,GAEVM,SAAQ,kBAAM3F,EAAiB,CAAES,KAAM,aAR5B,SASM6B,EATN,OASdsD,EATc,OAUdC,EAAY1B,EAAeyB,GAVb,uBAYhBT,EAAWS,GACXR,EAASS,GAbO,4CAAH,oDAeTE,GAGR,OAAO,MEMMC,EApEO,WAAO,IAAD,EACgB/F,mBAAwB,CAChEQ,KAAM,YAFkB,mBACnBuE,EADmB,KACJhF,EADI,OAIQC,mBAAiB,QAJzB,mBAInBgF,EAJmB,KAIRgB,EAJQ,OAKIhG,qBALJ,mBAKnBiF,EALmB,KAKVC,EALU,OAMAlF,mBAAiB,IANjB,mBAMnBlB,EANmB,KAMZqG,EANY,OAOYnF,oBAAU,GAPtB,mBAOnBjB,EAPmB,KAONC,EAPM,OAQIgB,oBAAkB,GARtB,mBAQnBF,EARmB,KAQVb,EARU,OASQe,mBAAiB,GATzB,mBASnBiG,EATmB,KASRC,EATQ,KAWpBC,EACJ,4BACE1G,QAAS,WACPyG,EAAaD,EAAY,GACzBhH,GAAYa,KAHhB,SAMSmG,EAAY,EAAZ,UAAmBA,EAAnB,UAAuC,OANhD,cAUF,OACE,kBAAC,WAAD,KACGA,EAAY,GAAKE,EAClB,yBAAK5G,UAAW0G,EAAY,EAAI,cAAgB,IAC9C,2BACEG,WAAY,SAAArE,GACI,UAAVA,EAAEvC,MACJwG,EAAajE,EAAEE,cAAcC,OAC7BnC,EAAiB,CAAES,KAAM,YACzBxB,EAAe,OANvB,sBAUsBgG,EACpB,kBAAC,EAAD,CACElF,QAASA,EACTb,WAAYA,EACZF,YAAaA,EACbC,eAAgBA,EAChBF,MAAOA,EACPiB,iBAAkBA,IAEpB,kBAAC,WAAD,CAAUsG,SAAU,4CAClB,kBAAC,EAAD,CACEtB,cAAeA,EACfhF,iBAAkBA,EAClBiF,UAAWA,EACXC,QAASA,EACTC,WAAYA,EACZpG,MAAOA,EACPqG,SAAUA,EACVC,iBAAkB,CAAEkB,OAAQ,GAAIC,QAAQ,MAG5C,4BACE9G,QAAS,WACPM,EAAiB,CAAES,KAAM,gBAF7B,iB,OCvDYgG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SDmI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,iB","file":"static/js/main.2c5959cc.chunk.js","sourcesContent":["import Snoowrap from \"snoowrap\";\nimport { CLIENT_ID, TOKEN_LATENCY, USER_AGENT } from \"./constants\";\n\ninterface AppOnlyOAuthToken {\n  access_token: string;\n  expires_in: number; // milliseconds\n  expiresOn: Date;\n}\n\nfunction isAppOnlyOAuthToken(object: any): object is AppOnlyOAuthToken {\n  return (\n    typeof object.access_token === \"string\" &&\n    typeof object.expires_in === \"number\"\n  );\n}\n\nlet token: AppOnlyOAuthToken;\nlet snoowrap: Snoowrap;\nlet error: Error;\n\nexport const refreshSnoowrap = () => {\n  if (error) {\n    throw error;\n  }\n  if (isValid()) {\n    return snoowrap;\n  }\n  throw refresh().catch(e => {\n    error = e;\n  });\n};\n\nconst isValid = () =>\n  snoowrap !== undefined &&\n  token !== undefined &&\n  token.expiresOn.getTime() - TOKEN_LATENCY > Date.now();\n\nconst refresh = async () => {\n  const form = new FormData();\n  form.set(\"grant_type\", \"https://oauth.reddit.com/grants/installed_client\");\n  form.set(\"device_id\", \"DO_NOT_TRACK_THIS_DEVICE\");\n  const response = await fetch(\"https://www.reddit.com/api/v1/access_token\", {\n    method: \"post\",\n    headers: { authorization: `Basic ${btoa(CLIENT_ID + \":\")}` },\n    body: form\n  });\n  if (!response.ok) {\n    throw new Error(\"Failed to retrieve OAuth token.\");\n  }\n  const tokenInfo = await response.json();\n  if (!isAppOnlyOAuthToken(tokenInfo)) {\n    throw new Error(\"Received wrongly formatted OAuth token.\");\n  }\n  token = tokenInfo;\n  token.expiresOn = new Date(Date.now() + tokenInfo.expires_in * 1000);\n  if (snoowrap !== undefined) {\n    snoowrap.accessToken = token.access_token;\n  } else {\n    snoowrap = new Snoowrap({\n      userAgent: USER_AGENT,\n      accessToken: token.access_token\n    });\n  }\n};\n","import React from \"react\";\nimport \"./Playlist.css\";\nimport { Song } from \"./types\";\n\nexport interface PlaylistProps {\n  songs: Song[];\n  currentSong: number;\n  setCurrentSong: React.Dispatch<React.SetStateAction<number>>;\n  setPlaying: React.Dispatch<React.SetStateAction<boolean>>;\n}\n\nexport const Playlist: React.FC<PlaylistProps> = ({\n  songs,\n  currentSong,\n  setCurrentSong,\n  setPlaying\n}) => {\n  const playlist = [];\n  for (const [index, song] of songs.entries()) {\n    let playlistClasses = \"playlist-entry\";\n    if (index === currentSong) {\n      playlistClasses += \" playlist-entry__playing\";\n    }\n    playlist.push(\n      <li className={playlistClasses} key={index}>\n        <button\n          className=\"playlist-entry__button\"\n          onClick={() => {\n            setCurrentSong(index);\n            setPlaying(true);\n          }}\n        >\n          {song.title}\n        </button>\n        {song.platform}\n      </li>\n    );\n  }\n  return <div className=\"playlist\">{playlist}</div>;\n};\n","import React, { Fragment, useState } from \"react\";\nimport ReactPlayer, { ReactPlayerProps } from \"react-player\";\nimport SoundCloudPlayer from \"react-player/lib/players/SoundCloud\";\nimport YouTubePlayer from \"react-player/lib/players/YouTube\";\nimport \"./Player.css\";\nimport { Playlist } from \"./Playlist\";\nimport { Platform, PlaylistEvent, Song } from \"./types\";\n\nexport interface PlayerProps {\n  playing: boolean;\n  setPlaying: React.Dispatch<React.SetStateAction<boolean>>;\n  currentSong: number;\n  setCurrentSong: React.Dispatch<React.SetStateAction<number>>;\n  songs: Song[];\n  setPlaylistEvent: React.Dispatch<React.SetStateAction<PlaylistEvent>>;\n}\n\nexport const Player: React.FC<PlayerProps> = ({\n  playing,\n  setPlaying,\n  currentSong,\n  setCurrentSong,\n  songs,\n  setPlaylistEvent\n}) => {\n  const [volume, setVolume] = useState<number>(1);\n  const [muted, setMuted] = useState<boolean>(false);\n  const currentPlatform =\n    songs[currentSong] === undefined ? undefined : songs[currentSong].platform;\n\n  const onEnded = () => {\n    if (songs[currentSong + 1] === undefined) {\n      setPlaylistEvent({ type: \"fetchMore\" });\n    }\n    setCurrentSong(currentSong + 1);\n  };\n\n  let ref = React.createRef<ReactPlayer>();\n\n  const playerProps = (targetPlatform: Platform): ReactPlayerProps =>\n    currentPlatform === targetPlatform\n      ? {\n          ref: ref,\n          url: songs[currentSong].url,\n          volume: volume,\n          muted: muted,\n          playing: playing,\n          onPlay: () => setPlaying(true),\n          onPause: () => setPlaying(false),\n          onReady: () => setTimeout(() => setPlaying(true), 100),\n          onEnded: onEnded,\n          onError: onEnded,\n          controls: true\n        }\n      : {\n          url: platformDefaultUrls[targetPlatform],\n          volume: volume,\n          muted: true,\n          playing: playing,\n          loop: true,\n          controls: true\n        };\n\n  return (\n    <Fragment>\n      <YouTubePlayer {...playerProps(\"youtube.com\")} />\n      <SoundCloudPlayer {...playerProps(\"soundcloud.com\")} />\n      <button\n        onClick={() =>\n          setCurrentSong(currentSong > 0 ? currentSong - 1 : currentSong)\n        }\n      >\n        Previous\n      </button>\n      <button onClick={() => setPlaying(!playing)}>\n        {playing ? \"Pause\" : \"Play\"}\n      </button>\n      <button onClick={onEnded}>Next</button>\n      <button\n        onClick={() => {\n          if (ref.current) {\n            ref.current.seekTo(ref.current.getDuration() - 5);\n          }\n        }}\n      >\n        Skip to end\n      </button>\n      <button onClick={() => setMuted(!muted)}>\n        {muted ? \"Unmute\" : \"Mute\"}\n      </button>\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1\"\n        step=\"0.01\"\n        defaultValue={volume}\n        onChange={e => setVolume(parseFloat(e.currentTarget.value))}\n      />\n      <Playlist\n        songs={songs}\n        currentSong={currentSong}\n        setCurrentSong={setCurrentSong}\n        setPlaying={setPlaying}\n      />\n    </Fragment>\n  );\n};\n\nconst platformDefaultUrls: { [key in Platform]: string } = {\n  \"youtube.com\": \"https://www.youtube.com/watch?v=GlCmAC4MHek\",\n  \"soundcloud.com\": \"https://soundcloud.com/seucheu/john-cage-433-8-bit-version\"\n};\n","import { version } from \"../package.json\";\n\nexport const USER_AGENT = `webapp:listennit:v${version} (by /u/twistitup)`;\nexport const CLIENT_ID = \"jihSDVLVs-dA0Q\";\nexport const TOKEN_LATENCY = 10000; // in milliseconds\n","import { Listing, Submission } from \"snoowrap\";\nimport { FetchMoreOptions } from \"snoowrap/dist/objects/Listing\";\nimport { refreshSnoowrap } from \"./SnoowrapCache\";\nimport { convertToSongs, PlaylistEvent, Song } from \"./types\";\n\ninterface PlaylistLoaderProps {\n  playlistEvent: PlaylistEvent;\n  setPlaylistEvent: React.Dispatch<React.SetStateAction<PlaylistEvent>>;\n  subreddit: string;\n  listing?: Listing<Submission>;\n  setListing: React.Dispatch<\n    React.SetStateAction<Listing<Submission> | undefined>\n  >;\n  songs: Song[];\n  setSongs: React.Dispatch<React.SetStateAction<Song[]>>;\n  fetchMoreOptions: FetchMoreOptions;\n}\n\nlet ongoingPromise: Promise<Listing<Submission>>;\n\nexport const PlaylistLoader: React.FC<PlaylistLoaderProps> = ({\n  playlistEvent,\n  setPlaylistEvent,\n  subreddit,\n  listing,\n  setListing,\n  songs,\n  setSongs,\n  fetchMoreOptions\n}) => {\n  if (playlistEvent.type === \"ready\") {\n    return null;\n  }\n\n  if (ongoingPromise) {\n    ongoingPromise.cancel();\n  }\n\n  const snoowrap = refreshSnoowrap();\n\n  if (\n    playlistEvent.type === \"refresh\" ||\n    (listing === undefined && playlistEvent.type === \"fetchMore\")\n  ) {\n    const fetch = async () => {\n      ongoingPromise = snoowrap\n        .getSubreddit(subreddit)\n        .getHot()\n        .finally(() => setPlaylistEvent({ type: \"ready\" }));\n      const tempListing = await ongoingPromise;\n      setListing(tempListing);\n      setSongs(convertToSongs(tempListing));\n    };\n    throw fetch();\n  } else if (playlistEvent.type === \"fetchMore\" && listing !== undefined) {\n    const fetchMore = async () => {\n      let tempListing = listing;\n      let tempSongs: Song[] = [];\n      while (tempSongs.length <= songs.length) {\n        ongoingPromise = ((tempListing\n          // Assert that it's a Promise since there is a bug in the library typing.\n          .fetchMore(fetchMoreOptions) as unknown) as Promise<\n          Listing<Submission>\n        >).finally(() => setPlaylistEvent({ type: \"ready\" }));\n        tempListing = await ongoingPromise;\n        tempSongs = convertToSongs(tempListing);\n      }\n      setListing(tempListing);\n      setSongs(tempSongs);\n    };\n    throw fetchMore();\n  }\n\n  return null;\n};\n","import { Submission } from \"snoowrap\";\n\nexport interface PlaylistEvent {\n  type: \"refresh\" | \"fetchMore\" | \"ready\";\n}\n\nexport interface Song {\n  title: string;\n  commentsUrl: string;\n  url: string;\n  platform: Platform;\n  votes: number;\n}\n\nexport type Platform = \"youtube.com\" | \"soundcloud.com\";\n\nexport const isPlatform = (object: any): object is Platform => {\n  return object === \"youtube.com\" || object === \"soundcloud.com\";\n};\n\nexport const convertToSongs = (\n  submissions: Submission[] | undefined\n): Song[] => {\n  if (submissions === undefined) {\n    return [];\n  }\n\n  return submissions.reduce<Song[]>((acc: Song[], submission: Submission) => {\n    const song = convertToSong(submission);\n    return song === undefined ? acc : acc.concat(song);\n  }, []);\n};\n\nexport const convertToSong = (submission: Submission): Song | undefined => {\n  if (\n    submission.secure_media === null ||\n    !isPlatform(submission.secure_media.type)\n  ) {\n    return undefined;\n  }\n\n  return {\n    title: submission.title,\n    commentsUrl: submission.permalink,\n    url: submission.url,\n    platform: submission.secure_media.type,\n    votes: submission.score\n  };\n};\n","import Bluebird from \"bluebird\";\nimport React, { Fragment, Suspense, useState } from \"react\";\nimport { Listing, Submission } from \"snoowrap\";\nimport \"./App.css\";\nimport { Player } from \"./Player\";\nimport { PlaylistLoader } from \"./PlaylistLoader\";\nimport { PlaylistEvent, Song } from \"./types\";\ndeclare global {\n  export interface Promise<T> extends Bluebird<T> {}\n}\n\nconst App: React.FC = () => {\n  const [playlistEvent, setPlaylistEvent] = useState<PlaylistEvent>({\n    type: \"refresh\"\n  });\n  const [subreddit, setSubreddit] = useState<string>(\"lofi\");\n  const [listing, setListing] = useState<Listing<Submission>>();\n  const [songs, setSongs] = useState<Song[]>([]);\n  const [currentSong, setCurrentSong] = useState(-1);\n  const [playing, setPlaying] = useState<boolean>(false);\n  const [lockCount, setLockCount] = useState<number>(3);\n\n  const lock = (\n    <button\n      onClick={() => {\n        setLockCount(lockCount - 1);\n        setPlaying(!playing);\n      }}\n    >\n      Press {lockCount > 1 ? `${lockCount} times` : \"once\"} to unlock\n    </button>\n  );\n\n  return (\n    <Fragment>\n      {lockCount > 0 && lock}\n      <div className={lockCount > 0 ? \"app__hidden\" : \"\"}>\n        <input\n          onKeyPress={e => {\n            if (e.key === \"Enter\") {\n              setSubreddit(e.currentTarget.value);\n              setPlaylistEvent({ type: \"refresh\" });\n              setCurrentSong(0);\n            }\n          }}\n        />\n        Current subreddit: {subreddit}\n        <Player\n          playing={playing}\n          setPlaying={setPlaying}\n          currentSong={currentSong}\n          setCurrentSong={setCurrentSong}\n          songs={songs}\n          setPlaylistEvent={setPlaylistEvent}\n        />\n        <Suspense fallback={<div>Loading...</div>}>\n          <PlaylistLoader\n            playlistEvent={playlistEvent}\n            setPlaylistEvent={setPlaylistEvent}\n            subreddit={subreddit}\n            listing={listing}\n            setListing={setListing}\n            songs={songs}\n            setSongs={setSongs}\n            fetchMoreOptions={{ amount: 10, append: true }}\n          />\n        </Suspense>\n        <button\n          onClick={() => {\n            setPlaylistEvent({ type: \"fetchMore\" });\n          }}\n        >\n          Fetch more\n        </button>\n      </div>\n    </Fragment>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.css\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}